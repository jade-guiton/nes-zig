const std = @import("std");

const Nes = @import("./nes.zig").Nes;

const AddrMode = enum {
    Impl,
    A,
    Imm,
    Rel,
    Abs,
    AbsX,
    AbsY,
    Zero,
    ZeroX,
    ZeroY,
    Ind,
    IndPreX,
    IndPostY,

    pub fn str(mode: AddrMode) [*:0]const u8 {
        return switch (mode) {
            .Impl => "impl",
            .A => "A",
            .Imm => "#",
            .Rel => "rel",
            .Abs => "abs",
            .AbsX => "abs,X",
            .AbsY => "abs,Y",
            .Zero => "zpg",
            .ZeroX => "zpg,X",
            .ZeroY => "zpg,Y",
            .Ind => "(ind)",
            .IndPreX => "(ind,X)",
            .IndPostY => "(ind),Y",
        };
    }
};
pub const Instr = struct {
    mne: *const [3:0]u8,
    mode: AddrMode,
};
fn instr(mne: *const [3:0]u8, mode: AddrMode) Instr {
    return Instr{ .mne = mne, .mode = mode };
}

pub const instructions = [256]Instr{
    instr("BRK", .Impl),
    instr("ORA", .IndPreX),
    instr("JAM", .Impl),
    instr("SLO", .IndPreX),
    instr("NOP", .Zero),
    instr("ORA", .Zero),
    instr("ASL", .Zero),
    instr("SLO", .Zero),
    instr("PHP", .Impl),
    instr("ORA", .Imm),
    instr("ASL", .A),
    instr("ANC", .Imm),
    instr("NOP", .Abs),
    instr("ORA", .Abs),
    instr("ASL", .Abs),
    instr("SLO", .Abs),
    instr("BPL", .Rel),
    instr("ORA", .IndPostY),
    instr("JAM", .Impl),
    instr("SLO", .IndPostY),
    instr("NOP", .ZeroX),
    instr("ORA", .ZeroX),
    instr("ASL", .ZeroX),
    instr("SLO", .ZeroX),
    instr("CLC", .Impl),
    instr("ORA", .AbsY),
    instr("NOP", .Impl),
    instr("SLO", .AbsY),
    instr("NOP", .AbsX),
    instr("ORA", .AbsX),
    instr("ASL", .AbsX),
    instr("SLO", .AbsX),
    instr("JSR", .Abs),
    instr("AND", .IndPreX),
    instr("JAM", .Impl),
    instr("RLA", .IndPreX),
    instr("BIT", .Zero),
    instr("AND", .Zero),
    instr("ROL", .Zero),
    instr("RLA", .Zero),
    instr("PLP", .Impl),
    instr("AND", .Imm),
    instr("ROL", .A),
    instr("ANC", .Imm),
    instr("BIT", .Abs),
    instr("AND", .Abs),
    instr("ROL", .Abs),
    instr("RLA", .Abs),
    instr("BMI", .Rel),
    instr("AND", .IndPostY),
    instr("JAM", .Impl),
    instr("RLA", .IndPostY),
    instr("NOP", .ZeroX),
    instr("AND", .ZeroX),
    instr("ROL", .ZeroX),
    instr("RLA", .ZeroX),
    instr("SEC", .Impl),
    instr("AND", .AbsY),
    instr("NOP", .Impl),
    instr("RLA", .AbsY),
    instr("NOP", .AbsX),
    instr("AND", .AbsX),
    instr("ROL", .AbsX),
    instr("RLA", .AbsX),
    instr("RTI", .Impl),
    instr("EOR", .IndPreX),
    instr("JAM", .Impl),
    instr("SRE", .IndPreX),
    instr("NOP", .Zero),
    instr("EOR", .Zero),
    instr("LSR", .Zero),
    instr("SRE", .Zero),
    instr("PHA", .Impl),
    instr("EOR", .Imm),
    instr("LSR", .A),
    instr("ALR", .Imm),
    instr("JMP", .Abs),
    instr("EOR", .Abs),
    instr("LSR", .Abs),
    instr("SRE", .Abs),
    instr("BVC", .Rel),
    instr("EOR", .IndPostY),
    instr("JAM", .Impl),
    instr("SRE", .IndPostY),
    instr("NOP", .ZeroX),
    instr("EOR", .ZeroX),
    instr("LSR", .ZeroX),
    instr("SRE", .ZeroX),
    instr("CLI", .Impl),
    instr("EOR", .AbsY),
    instr("NOP", .Impl),
    instr("SRE", .AbsY),
    instr("NOP", .AbsX),
    instr("EOR", .AbsX),
    instr("LSR", .AbsX),
    instr("SRE", .AbsX),
    instr("RTS", .Impl),
    instr("ADC", .IndPreX),
    instr("JAM", .Impl),
    instr("RRA", .IndPreX),
    instr("NOP", .Zero),
    instr("ADC", .Zero),
    instr("ROR", .Zero),
    instr("RRA", .Zero),
    instr("PLA", .Impl),
    instr("ADC", .Imm),
    instr("ROR", .A),
    instr("ARR", .Imm),
    instr("JMP", .Ind),
    instr("ADC", .Abs),
    instr("ROR", .Abs),
    instr("RRA", .Abs),
    instr("BVS", .Rel),
    instr("ADC", .IndPostY),
    instr("JAM", .Impl),
    instr("RRA", .IndPostY),
    instr("NOP", .ZeroX),
    instr("ADC", .ZeroX),
    instr("ROR", .ZeroX),
    instr("RRA", .ZeroX),
    instr("SEI", .Impl),
    instr("ADC", .AbsY),
    instr("NOP", .Impl),
    instr("RRA", .AbsY),
    instr("NOP", .AbsX),
    instr("ADC", .AbsX),
    instr("ROR", .AbsX),
    instr("RRA", .AbsX),
    instr("NOP", .Imm),
    instr("STA", .IndPreX),
    instr("NOP", .Imm),
    instr("SAX", .IndPreX),
    instr("STY", .Zero),
    instr("STA", .Zero),
    instr("STX", .Zero),
    instr("SAX", .Zero),
    instr("DEY", .Impl),
    instr("NOP", .Imm),
    instr("TXA", .Impl),
    instr("ANE", .Imm),
    instr("STY", .Abs),
    instr("STA", .Abs),
    instr("STX", .Abs),
    instr("SAX", .Abs),
    instr("BCC", .Rel),
    instr("STA", .IndPostY),
    instr("JAM", .Impl),
    instr("SHA", .IndPostY),
    instr("STY", .ZeroX),
    instr("STA", .ZeroX),
    instr("STX", .ZeroY),
    instr("SAX", .ZeroY),
    instr("TYA", .Impl),
    instr("STA", .AbsY),
    instr("TXS", .Impl),
    instr("TAS", .AbsY),
    instr("SHY", .AbsX),
    instr("STA", .AbsX),
    instr("SHX", .AbsY),
    instr("SHA", .AbsY),
    instr("LDY", .Imm),
    instr("LDA", .IndPreX),
    instr("LDX", .Imm),
    instr("LAX", .IndPreX),
    instr("LDY", .Zero),
    instr("LDA", .Zero),
    instr("LDX", .Zero),
    instr("LAX", .Zero),
    instr("TAY", .Impl),
    instr("LDA", .Imm),
    instr("TAX", .Impl),
    instr("LXA", .Imm),
    instr("LDY", .Abs),
    instr("LDA", .Abs),
    instr("LDX", .Abs),
    instr("LAX", .Abs),
    instr("BCS", .Rel),
    instr("LDA", .IndPostY),
    instr("JAM", .Impl),
    instr("LAX", .IndPostY),
    instr("LDY", .ZeroX),
    instr("LDA", .ZeroX),
    instr("LDX", .ZeroY),
    instr("LAX", .ZeroY),
    instr("CLV", .Impl),
    instr("LDA", .AbsY),
    instr("TSX", .Impl),
    instr("LAS", .AbsY),
    instr("LDY", .AbsX),
    instr("LDA", .AbsX),
    instr("LDX", .AbsY),
    instr("LAX", .AbsY),
    instr("CPY", .Imm),
    instr("CMP", .IndPreX),
    instr("NOP", .Imm),
    instr("DCP", .IndPreX),
    instr("CPY", .Zero),
    instr("CMP", .Zero),
    instr("DEC", .Zero),
    instr("DCP", .Zero),
    instr("INY", .Impl),
    instr("CMP", .Imm),
    instr("DEX", .Impl),
    instr("SBX", .Imm),
    instr("CPY", .Abs),
    instr("CMP", .Abs),
    instr("DEC", .Abs),
    instr("DCP", .Abs),
    instr("BNE", .Rel),
    instr("CMP", .IndPostY),
    instr("JAM", .Impl),
    instr("DCP", .IndPostY),
    instr("NOP", .ZeroX),
    instr("CMP", .ZeroX),
    instr("DEC", .ZeroX),
    instr("DCP", .ZeroX),
    instr("CLD", .Impl),
    instr("CMP", .AbsY),
    instr("NOP", .Impl),
    instr("DCP", .AbsY),
    instr("NOP", .AbsX),
    instr("CMP", .AbsX),
    instr("DEC", .AbsX),
    instr("DCP", .AbsX),
    instr("CPX", .Imm),
    instr("SBC", .IndPreX),
    instr("NOP", .Imm),
    instr("ISC", .IndPreX),
    instr("CPX", .Zero),
    instr("SBC", .Zero),
    instr("INC", .Zero),
    instr("ISC", .Zero),
    instr("INX", .Impl),
    instr("SBC", .Imm),
    instr("NOP", .Impl),
    instr("SBC", .Imm),
    instr("CPX", .Abs),
    instr("SBC", .Abs),
    instr("INC", .Abs),
    instr("ISC", .Abs),
    instr("BEQ", .Rel),
    instr("SBC", .IndPostY),
    instr("JAM", .Impl),
    instr("ISC", .IndPostY),
    instr("NOP", .ZeroX),
    instr("SBC", .ZeroX),
    instr("INC", .ZeroX),
    instr("ISC", .ZeroX),
    instr("SED", .Impl),
    instr("SBC", .AbsY),
    instr("NOP", .Impl),
    instr("ISC", .AbsY),
    instr("NOP", .AbsX),
    instr("SBC", .AbsX),
    instr("INC", .AbsX),
    instr("ISC", .AbsX),
};

pub fn disasm(nes: *Nes, add: u16, writer: anytype) !void {
    const op = nes.read(add);
    const ins = instructions[op];
    try writer.writeAll(ins.mne);
    if (ins.mode != AddrMode.Impl) {
        try writer.writeAll(" ");
        switch (ins.mode) {
            .Impl => unreachable,
            .A => try writer.writeAll("A"),
            .Imm => try std.fmt.format(writer, "#{x:0>2}", .{nes.read(add +% 1)}),
            .Rel => {
                const jump = @as(i8, @bitCast(nes.read(add +% 1)));
                if (jump > 0) {
                    try std.fmt.format(writer, "*+{d}", .{jump});
                } else {
                    try std.fmt.format(writer, "*{d}", .{jump});
                }
            },
            .Abs => try std.fmt.format(writer, "{x:0>4}", .{nes.read16(add +% 1)}),
            .AbsX => try std.fmt.format(writer, "{x:0>4},X", .{nes.read16(add +% 1)}),
            .AbsY => try std.fmt.format(writer, "{x:0>4},Y", .{nes.read16(add +% 1)}),
            .Zero => try std.fmt.format(writer, "{x:0>2}", .{nes.read(add +% 1)}),
            .ZeroX => try std.fmt.format(writer, "{x:0>2},X", .{nes.read(add +% 1)}),
            .ZeroY => try std.fmt.format(writer, "{x:0>2},Y", .{nes.read(add +% 1)}),
            .Ind => try std.fmt.format(writer, "({x:0>4})", .{nes.read16(add +% 1)}),
            .IndPreX => try std.fmt.format(writer, "({x:0>4},X)", .{nes.read16(add +% 1)}),
            .IndPostY => try std.fmt.format(writer, "({x:0>4}),Y", .{nes.read16(add +% 1)}),
        }
    }
}
